<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ramp and Projectile Lab Simulation</title>
    <style>
        body {
            font-family: sans-serif;
            background: #f0f8ff; /* AliceBlue */
            margin: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #mainContainer {
            display: flex;
            width: 1150px; /* Adjusted width for wider canvas */
            margin-bottom: 10px;
             align-items: flex-start; /* Align items to top */
        }
        #canvasContainer {
            position: relative;
            background: #ffffff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 10px; /* Added rounded corners to container */
            overflow: hidden; /* Ensures content respects rounded corners */
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            border-radius: 10px; /* Added rounded corners to canvas */
        }
        #rangeBox {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.9); /* Slightly less transparent */
            border: 2px solid #007bff;
            border-radius: 5px;
            padding: 8px 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            display: none; /* Hidden initially */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10; /* Ensure it's on top */
        }
         #rangeBox span {
             color: #007bff; /* Blue value */
             margin-left: 5px;
         }

        #controlsContainer {
            margin-left: 25px;
            padding: 15px;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            min-width: 250px; /* Ensure enough space */
            max-height: 600px; /* Limit height if controls get long */
             overflow-y: auto; /* Add scroll if needed */
        }
        /* ... (rest of CSS remains the same) ... */
         .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        .control-group input[type="range"] {
            width: 160px;
            vertical-align: middle;
             cursor: pointer;
        }
        .control-group input[type="number"] {
            width: 70px;
            margin-left: 10px;
            vertical-align: middle;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
         .control-group input[type="checkbox"] {
             vertical-align: middle;
             margin-right: 8px;
             cursor: pointer;
         }
         #mathModeLabel {
             font-weight: normal;
             color: #333;
             cursor: pointer;
         }
        button {
            padding: 10px 18px;
            margin-right: 8px;
            margin-top: 10px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        #resetBtn {
            background-color: #6c757d;
        }
        #resetBtn:hover {
            background-color: #5a6268;
        }
         h2 {
             color: #333;
             margin-bottom: 25px;
         }
    </style>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <h2>Ramp and Projectile Lab Simulation</h2>

    <div id="mainContainer">
        <div id="canvasContainer">
             <canvas id="simCanvas" width="830" height="500"></canvas>
            <div id="rangeBox">
                <strong>Range:</strong> <span id="rangeVal">0.000</span> m
            </div>
        </div>

        <div id="controlsContainer">
             <h4>Simulation Setup</h4>
            <div class="control-group">
                 <label for="tableHeightRange">Table Height (m):</label>
                <input type="range" id="tableHeightRange" min="0.5" max="2.0" step="0.05" value="1.0">
                <input type="number" id="tableHeightNumber" min="0.5" max="2.0" step="0.05" value="1.0">
            </div>
            <div class="control-group">
                <label for="rampAngleRange">Ramp Angle (°):</label>
                <input type="range" id="rampAngleRange" min="10" max="60" step="1" value="30">
                <input type="number" id="rampAngleNumber" min="10" max="60" step="1" value="30">
            </div>
            <div class="control-group">
                <label for="rampHeightNumber">Ramp Start Height (m):</label>
				<input type="range" id="rampHeightRange" min="0.1" max="0.9" step="0.05" value="0.7">
                 <input type="number" id="rampHeightNumber" min="0.1" max="0.9" step="0.05" value="0.7">
            </div>
            <div class="control-group">
                <label for="muRange">Table Friction (μ):</label>
                <input type="range" id="muRange" min="0" max="0.5" step="0.01" value="0.0">
                <input type="number" id="muNumber" min="0" max="0.5" step="0.01" value="0.0">
            </div>
            <div class="control-group">
                <label for="launchAngleRange">Launch Ramp Angle (°):</label>
                <input type="range" id="launchAngleRange" min="0" max="80" step="1" value="0">
                <input type="number" id="launchAngleNumber" min="0" max="80" step="1" value="0">
            </div>
            <div class="control-group">
                 <label id="mathModeLabel" for="mathModeCheckbox">
                    <input type="checkbox" id="mathModeCheckbox"> Math Mode (Ideal, No Error)
                </label>
             </div>

            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn" title="Reset Simulation"><i class="fas fa-redo"></i></button> <!-- Reset button with icon and hover note -->
        </div>
    </div>

    <script>
        // --- Constants and Setup ---
        const canvas = document.getElementById("simCanvas");
        const ctx = canvas.getContext("2d");
        const scale = 150; // Pixels per meter
        const g = 9.81;  // m/s²
        const launchRampVisualLength = 0.2; // m
        const maxVisualRampLength = 1.5;   // m
        const errorMagnitude = 0.03; // +/- 3% range error in Real Mode
        const topMargin_px = 60; // Space above the highest point (ramp top)

        // --- Get Control Elements ---
        const tableHeightRange = document.getElementById("tableHeightRange");
        const tableHeightNumber = document.getElementById("tableHeightNumber");
        const rampAngleRange = document.getElementById("rampAngleRange");
        const rampAngleNumber = document.getElementById("rampAngleNumber");
        const rampHeightRange = document.getElementById("rampHeightRange");
		const rampHeightNumber = document.getElementById("rampHeightNumber");
        const muRange = document.getElementById("muRange");
        const muNumber = document.getElementById("muNumber");
        const launchAngleRange = document.getElementById("launchAngleRange");
        const launchAngleNumber = document.getElementById("launchAngleNumber");
        const mathModeCheckbox = document.getElementById("mathModeCheckbox");
        const rangeVal = document.getElementById("rangeVal");
        const rangeBox = document.getElementById("rangeBox");
        const startBtn = document.getElementById("startBtn");
        const resetBtn = document.getElementById("resetBtn");


        // --- Simulation State Variables ---
        let animationId;
        let simulationRunning = false;
        let isMathMode = false;
        let lastTime;
        let trail = [];
        let cameraOffset = 0;

        let ball = {
            radius: 0.03, x: 0, y: 0, phase: 'idle', v: 0, s_travelled: 0
        };

        // Environment/Setup Parameters
        let tableHeight_m, rampAngleDeg, rampAngleRad, rampStartHeight_m, mu, launchAngleDeg, launchAngleRad;
        let tableTopY_px, tableStartX_px, tableEdgeX_px, floorY_px;
        let rampTravelDistance_m;
        let rampBottomX_px, rampBottomY_px, rampActualTopX_px, rampActualTopY_px;
        let launchVisualTopX_px, launchVisualTopY_px;

        // Projectile State
        let projectileStartTime, projectileInitialX_px, projectileInitialY_px, projectileVx_mps, projectileVy_mps;

        // Measured Results
        let actualTimeOfFlight = NaN;
        let actualRange = NaN;


        // --- Input Synchronization ---
        function syncInputs(rangeInput, numberInput) {
            numberInput.value = rangeInput.value;
        }
        function syncRange(rangeInput, numberInput) {
            const val = parseFloat(numberInput.value);
            if (!isNaN(val)) {
                const min = parseFloat(rangeInput.min);
                const max = parseFloat(rangeInput.max);
                if (val >= min && val <= max) {
                    rangeInput.value = numberInput.value;
                } else if (val < min) {
                    numberInput.value = min;
                    rangeInput.value = min;
                } else {
                    numberInput.value = max;
                    rangeInput.value = max;
                }
            }
        }
        [
            { range: tableHeightRange, number: tableHeightNumber },
            { range: rampAngleRange, number: rampAngleNumber },
            { range: muRange, number: muNumber },
            { range: launchAngleRange, number: launchAngleNumber }
        ].forEach(pair => {
            pair.range.addEventListener("input", () => {
                syncInputs(pair.range, pair.number);
                if (!simulationRunning) initSimulation();
            });
            pair.number.addEventListener("input", () => {
                syncRange(pair.range, pair.number);
                if (!simulationRunning) initSimulation();
            });
        });

        rampHeightRange.addEventListener("input", () => {
            syncInputs(rampHeightRange, rampHeightNumber);
            if (!simulationRunning) initSimulation();
        });

        rampHeightNumber.addEventListener("input", () => {
            const val = parseFloat(rampHeightNumber.value);
            const min = parseFloat(rampHeightNumber.min);
            const max = parseFloat(rampHeightNumber.max);
            if (isNaN(val)) {
                rampHeightNumber.value = min;
            } else if (val < min) {
                rampHeightNumber.value = min;
            } else if (val > max) {
                rampHeightNumber.value = max;
            }
            rampHeightRange.value = rampHeightNumber.value;
            if (!simulationRunning) initSimulation();
        });
        mathModeCheckbox.addEventListener("change", () => {
            if (!simulationRunning) initSimulation();
        });


        // --- Display Update ---
         function updateRangeDisplay() {
             if (!isNaN(actualRange)) {
                 rangeVal.textContent = actualRange.toFixed(2);
                 rangeBox.style.display = "block";
             } else {
                 rangeBox.style.display = "none";
             }
         }


        // --- Drawing Functions ---
        function drawSky() {
             ctx.fillStyle = "#e6f7ff";
             ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawGround() {
            const leftExtent  = -canvas.width * 2;
            const rightExtent =  canvas.width * 3;
            const groundWidth = rightExtent - leftExtent;

            ctx.fillStyle = "#90EE90";
            ctx.fillRect(leftExtent, floorY_px, groundWidth, canvas.height - floorY_px + 50);

            ctx.strokeStyle = "#556B2F";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(leftExtent,  floorY_px);
            ctx.lineTo(rightExtent, floorY_px);
            ctx.stroke();
        }


        function drawTable() {
             // Draw table surface
             let tableGradient = ctx.createLinearGradient(0, tableTopY_px, 0, tableTopY_px + 20);
             tableGradient.addColorStop(0, "#CD853F"); // Peru
             tableGradient.addColorStop(1, "#A0522D"); // Sienna
             ctx.fillStyle = tableGradient;
             ctx.fillRect(tableStartX_px, tableTopY_px, tableEdgeX_px - tableStartX_px, 20); // Table thickness 20px

              // Draw table legs / front face down to floor
             ctx.fillStyle = "#A0522D"; // Sienna
             ctx.fillRect(tableStartX_px, tableTopY_px + 20, tableEdgeX_px - tableStartX_px, floorY_px - (tableTopY_px + 20));

             // Add a subtle border to the table top for definition
             ctx.strokeStyle = "#8B4513"; /* SaddleBrown */
             ctx.lineWidth = 1;
             ctx.strokeRect(tableStartX_px, tableTopY_px, tableEdgeX_px - tableStartX_px, 20);

             // Draw table edge line clearly down to floor
             ctx.strokeStyle = "#000000";
             ctx.lineWidth = 2;
             ctx.beginPath();
             ctx.moveTo(tableEdgeX_px, tableTopY_px); // Start at top surface edge
             ctx.lineTo(tableEdgeX_px, floorY_px);   // Go down to floor level
             ctx.stroke();
        }

        function drawRamp() {
             // Draw the actual ramp track the ball uses
            ctx.strokeStyle = "#607D8B"; // Blue Grey
            ctx.lineWidth = 5;
             ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(rampActualTopX_px, rampActualTopY_px);
            ctx.lineTo(rampBottomX_px, rampBottomY_px);
            ctx.stroke();
        }

        function drawLaunchRampVisual() {
             // Draw VISUAL launch ramp (dashed line)
             if (launchAngleDeg > 0) {
                ctx.strokeStyle = "#FF69B4"; // Hot Pink
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(tableEdgeX_px, tableTopY_px);
                ctx.lineTo(launchVisualTopX_px, launchVisualTopY_px);
                ctx.stroke();
                ctx.setLineDash([]);
             }
        }

        function drawBallItself(x_px, y_px) {
            ctx.beginPath();
            ctx.fillStyle = "#FF4136";
            ctx.arc(x_px, y_px, ball.radius * scale, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = "#A00000";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawShadow(ballX_px, ballY_px) {
            const heightAboveGround_px = Math.max(0, floorY_px - ballY_px - ball.radius*scale);
            const maxShadowDistance = (tableHeight_m + 0.5) * scale;

            if (heightAboveGround_px < maxShadowDistance) {
                const shadowFactor = Math.max(0.1, 1 - (heightAboveGround_px / maxShadowDistance));
                const sizeFactor = Math.max(0.3, 1 - 0.5 * (heightAboveGround_px / maxShadowDistance));

                ctx.beginPath();
                ctx.fillStyle = `rgba(0, 0, 0, ${0.4 * shadowFactor})`;
                ctx.ellipse(
                    ballX_px + 5,
                    floorY_px,
                    ball.radius * scale * 1.1 * sizeFactor,
                    ball.radius * scale * 0.4 * sizeFactor,
                    0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }


        function drawTrail() {
            trail.forEach((pos, i) => {
                let alpha = 0.4 * (i / trail.length);
                ctx.beginPath();
                ctx.fillStyle = `rgba(255, 65, 54, ${alpha})`;
                ctx.arc(pos.x, pos.y, ball.radius * scale * (0.4 + 0.6 * (i / trail.length)), 0, 2 * Math.PI);
                ctx.fill();
            });
        }


        // --- Initialization ---
        function initSimulation() {
            cancelAnimationFrame(animationId);
            simulationRunning = false;
            cameraOffset = 0;
            trail = [];
            actualTimeOfFlight = NaN;
            actualRange = NaN;
            ball.phase = 'idle';

            // Get input values
            tableHeight_m = parseFloat(tableHeightNumber.value);
            rampAngleDeg = parseFloat(rampAngleNumber.value);
            rampAngleRad = rampAngleDeg * Math.PI / 180;
            rampStartHeight_m = parseFloat(rampHeightNumber.value);
            mu = parseFloat(muNumber.value);
            launchAngleDeg = parseFloat(launchAngleNumber.value);
            launchAngleRad = launchAngleDeg * Math.PI / 180;
            isMathMode = mathModeCheckbox.checked;

            // --- Geometric calculations (Revised for better layout) ---
            // Define floor and table top based on top margin
            tableTopY_px = topMargin_px + rampStartHeight_m * scale;
            floorY_px = tableTopY_px + tableHeight_m * scale;

            // Ensure canvas is tall enough, add buffer
             if (floorY_px + 50 > canvas.height) {
                 console.warn("Canvas might be too short for the chosen heights.");
             }

            tableEdgeX_px = canvas.width * 0.5;
            tableStartX_px = canvas.width * 0.1;


            // Calculate ramp geometry based on start height
            if (Math.sin(rampAngleRad) < 1e-6) rampAngleRad = 10 * Math.PI/180;
            rampTravelDistance_m = rampStartHeight_m / Math.sin(rampAngleRad);
            rampTravelDistance_m = Math.min(rampTravelDistance_m, maxVisualRampLength);
            rampStartHeight_m = rampTravelDistance_m * Math.sin(rampAngleRad);

            // Ramp bottom connects to table visually, adjust Y to match tableTopY_px
            rampBottomY_px = tableTopY_px;
            rampBottomX_px = tableStartX_px + 50;
            // Calculate ramp top based on bottom position and travel distance/angle
            rampActualTopX_px = rampBottomX_px - rampTravelDistance_m * Math.cos(rampAngleRad) * scale;
            rampActualTopY_px = rampBottomY_px - rampTravelDistance_m * Math.sin(rampAngleRad) * scale;


            // Visual launch ramp end point
            launchVisualTopX_px = tableEdgeX_px + launchRampVisualLength * scale * Math.cos(launchAngleRad);
            launchVisualTopY_px = tableTopY_px - launchRampVisualLength * scale * Math.sin(launchAngleRad);

            // Set ball starting position on the ramp
            ball.x = rampActualTopX_px;
            ball.y = rampActualTopY_px;
            ball.v = 0;
            ball.s_travelled = 0;
            ball.phase = 'ramp';

            const leftMargin = 60;
            const leftMostX  = Math.min(rampActualTopX_px, rampBottomX_px);
            cameraOffset = Math.min(0, leftMostX - leftMargin);

            updateRangeDisplay();
            drawStaticFrame();
        }

        // --- Draw Static Scene ---
        function drawStaticFrame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSky();
            ctx.save();
            ctx.translate(-cameraOffset, 0);

            drawGround();
            drawRamp();         // Draw ramp BEFORE table
            drawTable();        // Draw table AFTER ramp to avoid clipping
            drawLaunchRampVisual();
            drawBallItself(ball.x, ball.y);
            ctx.restore();
        }

        // --- Main Update Loop ---
        function update(timestamp) {
            if (!simulationRunning) return;

            if (!lastTime) lastTime = timestamp;
            const dt = Math.min((timestamp - lastTime) / 1000, 0.03);
            lastTime = timestamp;

            if (ball.phase === 'ramp') {
                 const a = (5/7) * g * Math.sin(rampAngleRad);
                 let deltaS = ball.v * dt + 0.5 * a * dt * dt;
                 ball.v += a * dt;
                 ball.s_travelled += deltaS;

                 if (ball.s_travelled >= rampTravelDistance_m) {
                     ball.s_travelled = rampTravelDistance_m;
                     let v_bottom = Math.sqrt(2 * a * ball.s_travelled);
                     ball.v = v_bottom > 0 ? v_bottom : 0;
                     ball.phase = 'table';
                     ball.x = rampBottomX_px;
                     ball.y = tableTopY_px - ball.radius * scale;
                     trail = [];
                 } else {
                     ball.x = rampActualTopX_px + ball.s_travelled * Math.cos(rampAngleRad) * scale;
                     ball.y = rampActualTopY_px + ball.s_travelled * Math.sin(rampAngleRad) * scale;
                 }

            } else if (ball.phase === 'table') {
                 const a = -mu * g;
                 let dx_m = ball.v * dt + 0.5 * a * dt * dt;
                 let next_v = Math.max(0, ball.v + a * dt);
                 let next_x_px = ball.x + dx_m * scale;

                 if (next_x_px >= tableEdgeX_px) {
                     let dist_to_edge_px = tableEdgeX_px - ball.x;
                     let t_to_edge = (ball.v > 0) ? (dist_to_edge_px / scale) / ball.v : 0;
                     t_to_edge = Math.max(0, t_to_edge);

                     ball.v = Math.max(0, ball.v + a * t_to_edge);

                     ball.phase = 'projectile';
                     ball.x = tableEdgeX_px;
                     ball.y = tableTopY_px - ball.radius * scale;

                     let vLeaving_actual = ball.v;
                     projectileVx_mps = vLeaving_actual * Math.cos(launchAngleRad);
                     projectileVy_mps = vLeaving_actual * Math.sin(launchAngleRad);

                     projectileInitialX_px = ball.x;
                     projectileInitialY_px = ball.y;
                     projectileStartTime = timestamp - Math.max(0, dt - t_to_edge) * 1000;

                     trail = [];
                 } else {
                     ball.v = next_v;
                     ball.x = next_x_px;
                     ball.y = tableTopY_px - ball.radius * scale;
                 }

            } else if (ball.phase === 'projectile') {
                const t = (timestamp - projectileStartTime) / 1000;

                ball.x = projectileInitialX_px + projectileVx_mps * t * scale;
                let deltaY_meters = projectileVy_mps * t - 0.5 * g * t * t;
                ball.y = projectileInitialY_px - deltaY_meters * scale;

                if (ball.y + ball.radius * scale >= floorY_px) {
                    ball.y = floorY_px - ball.radius * scale;
                    ball.phase = 'landed';
                    simulationRunning = false;
                    cancelAnimationFrame(animationId);

                    actualTimeOfFlight = (timestamp - projectileStartTime) / 1000;
                    actualRange = (ball.x - projectileInitialX_px) / scale;

                    if (!isMathMode) {
                        let errorFactor = 1 + (Math.random() * 2 - 1) * errorMagnitude;
                        actualRange *= errorFactor;
                        actualRange = Math.max(0, actualRange);
                    }
                    updateRangeDisplay();
                }
            } else if (ball.phase === 'landed') {
                 // Do nothing
            }

            // --- Panning ---
             const relativeX = ball.x - cameraOffset;
             const followThresholdRight = canvas.width * 0.55;
             const followThresholdLeft = canvas.width * 0.25;
             if (relativeX > followThresholdRight) { cameraOffset += (relativeX - followThresholdRight) * 0.1; }
             else if (relativeX < followThresholdLeft && cameraOffset > 0) { cameraOffset += (relativeX - followThresholdLeft) * 0.1; cameraOffset = Math.max(0, cameraOffset); }


            // --- Drawing ---
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSky();
            ctx.save();
            ctx.translate(-cameraOffset, 0);

            drawGround();
            drawRamp();         // Draw ramp BEFORE table
            drawTable();        // Draw table AFTER ramp to avoid clipping
            drawLaunchRampVisual();

             if (ball.phase === 'ramp' || ball.phase === 'table' || ball.phase === 'projectile') {
                 trail.push({ x: ball.x, y: ball.y });
                 if (trail.length > 15) trail.shift();
             }
             drawTrail();

             if (ball.phase === 'projectile') {
                 drawShadow(ball.x, ball.y);
             }
             drawBallItself(ball.x, ball.y);


            ctx.restore();

            if (simulationRunning) {
                animationId = requestAnimationFrame(update);
            }
        }

        // --- Event Listeners ---
        startBtn.addEventListener("click", () => { if (simulationRunning) return; initSimulation(); simulationRunning = true; lastTime = null; animationId = requestAnimationFrame(update); });
        resetBtn.addEventListener("click", () => { cancelAnimationFrame(animationId); simulationRunning = false; lastTime = null; initSimulation(); });

        // --- Initial Load ---
        initSimulation();

        // Handle window resize to adjust canvas dimensions
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;

            canvas.width = containerWidth;
            canvas.height = containerHeight;

            initSimulation();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

    </script>
</body>
</html>
